This document contains various notes for a redesign of the protocol
handling of LWP.  The goal is to be able to support HTTP/1.1 and
multiple connections and at the same time be able to support the old
interfaces.  The old interface will be built on top of the new
event-driven model. Some of the things that are not in conflict with
the old LWP will be integrated directly as they mature.

All communication will be based on IO::Socket::INET or on the Net::
modules where they are applicable.  Perhaps we ought to build a
Net::HTTP module?  All timeout handling should be based on a central
event-loop.  No more alarm calls.  When Perl get an official
event-loop we will use it and I believe that Nick is working on it
together with Tk.  Using the same event-loop is also a requirement for
happy Tk/LWP based applications in the future.

There can be multiple connections to the same or different servers.
Requests can be pipelined to HTTP/1.1 servers.

Much of this work is among others inspired by Marc's LWP::ParallelUA.

------------------------------------------------------------------

LWP::UserAgent

    %servers{"$host:$port"}
          # need $port since we don't index the protocol
    $scheduler
    $default_headers (UserAgent, From,....)
    $timeouts
    $cookie_jar... (generalized to something that modifies/monitors
          requests/responses???)

    $proxies
       # also something to support proxy authentication

    # the main route for adding requests are:
    $ua->$scheduler->spool();
    
    # the old $ua->request ($ua->simple_request) interfaces will be
    # emulated somehow.
         $ua->$scheduler->spool();
         LWP::EventLoop::wait_for_completion();
         return $res;


LWP::Request
    # same as before, but also hold $ua->request parameters.  Should it
    # then be a subclass?
    $arg       (undef, $file, \&callback)
    $size      (read size hint)
    $redirect  (redirect behaviour, scalar or callback)
    $prot      (might override protocol choosen, make HTTP/1.0 request to
                a HTTP/1.1 server or HTTP/1.1 request to an unknown server)
    $proxy
    $timeout


LWP::Server

    # This holds all the information that the UA needs to keep about
    # the servers it communicates with.  This is the place to remember
    # various state (not cookies) about authetication and capabilities
    # of servers.
    #
    # There should be some support of making (some of) this information
    # persistent between LWP runs.

    $netloc     'www.sn.no:8080'
    $protocol   "HTTP/1.0", "HTTP/1.1", "FTP",...  # whatever
    $pipeline   bool
    $keep_alive bool
    $max_connections    # limit connections to this server

    $last_request       time() (support nice robots and such)
    $num_requests       # counter (don't really know why we want this)

    @pending_request
    @connections

    # support authentication without unnecessary round-trips
    %credentials
    %realms

    $robot_rules        # if applicable


LWP::Connection (subclassed for various protocols)

    $server
    # These are attributes needed to support HTTP/1.1.
    $socket
    $current_request
    @pending_responses
    $current_response      $response (might be defined to be first of @pending)
    $last_activity         time()
    $pipeline              #send new request without waiting for response first
    $keep_alive            #seconds to live while idle
    $request_limit (max_request, decremented for each request)

    # When a connection has been created it will have a reference to
    # it's server.  It will then start eating of the @pending_request
    # queue.  Various parameters govern how greedy it will be.


LWP::Auth

    # Knows about different authentications schemes.  Different subclasses
    # for Basic/Digest/....
        # will be loaded and invoked on demand.  Takes a response as
        # parameter and will then return a response or a request.  If
        # it is a request it will be rescheduled.  Perhaps we could
        # handle redirects with the same kind of module.  Something
        # which is invoked for any client errors or redirects.



LWP::EventLoop
   - register filehandles (mostly sockets) for readable/writeable callbacks
   - timeout callbacks
   - wrapper around Tk's MainLoop

   $loop->loop_until($something);  # let things happen



LWP::Scheduler

   # I am not sure which one of these should be represented
   @active_servers
   @connections

   $ua  # makes callbacks (circular references are not good to have)
   $max_connections  # limit total number of connections from this client

   # this might in fact be the $ua, but a separate scheduler class
   # should make it easier to make subclasses that have a different
   # scheduling policy

   # These are called by connections when the corresponding event
   # happens.  This might result in rescheduling.
   $sched->no_more_pending($connection);  # but not closed (keep alive)
   $sched->closed($connection);

   $sched->spool($request);
       # will lookup server (create one if it does not exists) and add
       # this request as @pending_request (then call $sched->_sched)

   $sched->_sched
       # will pick some servers (with @pending_request) and create
       # connections for them.

   # The scheduler will also set up timer callbacks so that it will
   # sometimes wakeup and kill of idle connections (keep-alives).
          # perhaps the connections should take care of this
          # themselves.  yes, I think so!

   $sched->kill_server();  # kills all connections (and pending requests)
                           # to the given server.
   $sched->kill_all();


LWP::Simple
   # make it short-cut for simple HTTP request without redirect and
   # when no proxies are present.  It should not even have to load
   # all the other grummy stuff.
