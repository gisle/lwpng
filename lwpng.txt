# $Id$
# This is supposed to be an article about libwww-perl-6 for the Perl
# conference in August 1998.

# Note that figures should be included at the location of the
# [[figX.ps]] markers in this text.


=Title LWPng - Adding HTTP/1.1 support to libwww-perl

=Author Gisle Aas <gisle@aas.no>

=begin pc98submissions@perl.org

(no affiliation)

Contact information:

  Email:  gisle@aas.no
  Phone:  +47 5533 0252

  Smail:  Gisle Aas
          Furubotn 42
          N-5082 Eidsvågneset
          Norway

=end pc98submissions@perl.org


=head1 Abstract

The I<libwww-perl> library (often abbreviated LWP) is a collection of
Perl modules which provides a programming interface to the World-Wide
Web.  The library is currently in use for a wide range of Web
applications.

This article describes a redesign of the libwww-perl library in order
to provide support for HTTP/1.1 clients.  The new library allows
client applications to utilize multiple persistent connections to the
servers it communicates with.  The redesign is based on the adoption
of an event-driven framework.  Requests are registered with the
library and will receive callback events as the responses come back
from the servers.  The library tries to match the registered requests
with the persistent connections it has available or creates new
connections when necessary.

Not all details of the programming interface have been settled.
More experience with non-trivial applications built on top of the new
library is still needed.


=head1 Introduction

Libwww-perl is a collection of Perl modules which provide a simple and
consistent programming interface (API) to the World-Wide Web [1].  The
main focus of the library is to provide classes and functions that
allow you to write WWW clients, thus libwww-perl is said to be a WWW
client library. The library also contains modules that are of more
general use, and even classes that help you implement simple HTTP
servers.

The libwww-perl package has been quite successful at implementing a
wide range of web client applications and as a support tool for
server-side programs and programmers.  One important feature that
has been lacking is support for the new version of the HTTP protocol,
HTTP/1.1.  This article describes the redesign that has taken place in
order to add such support to libwww-perl.


=head1 A short history of HTTP

HTTP is a simple network protocol based on the request/response
paradigm.  A client establishes a connection with a server and sends a
request message to the server.  The server then returns a response
message.

HTTP started out as an extremely simple protocol where the client
connected to a server, sent a line saying "GET <name>" and the server
returned the resource identified by <name> and closed the connection.
This version of the protocol has since been dubbed HTTP/0.9.

The next revision gave us HTTP/1.0, which is still deployed in most
servers and clients today [2].  It adds a protocol version number and
MIME-like messages for both the request from the client and the
response from the server [3].  This makes it possible to attach extra
information about requests/responses and to carry meta-information
describing the content of these messages.  Responses now also start
with a status line that encodes the overall outcome of the request.
These enhancements make the protocol extensible.

The next step was/is HTTP/1.1 which tries to fix some of the
shortcomings of the HTTP/1.0 protocol [4,5]. One simple but important
change is that the Host header is now mandatory. This makes it
possible to serve multiple domains from a single server without
allocating a new IP-address to each domain.  Another change is support
for partial content messages.  The support for caching and proxies has
also been greatly clarified and improved upon.  For special
applications there is a standard mechanism of switching away from
HTTP/1.1 to some other (hopefully more suitable) protocol on the
established connection.

The most important change with HTTP/1.1 is the introduction of
persistent connections.  This means that more than one
request/response exchange can take place on a single TCP connection
between a client and a server.  This improves performance and
generally interacts much better with how TCP works underneath.  In
order to be able to do this, the communicating peers must have some
way to tell the extent of the messages on the wire. For HTTP/1.0, the
only way to do this was by either using the Content-Length header or
by closing the connection (which was only an option for the server).
Use of the Content-Length header is not appropriate when the length of
the message can not be determined in advance.  HTTP/1.1 introduces two
new ways to delimit messages; the chunked transfer encoding and the
self delimiting multipart content types.  The chunked transfer
encoding means that the message is broken into chunks, each of
arbitrary size and each preceded by a line specifying the number of
bytes in the chunk.  The multipart types use a special boundary byte
pattern as a delimiter for the messages.

With persistent connections one can improve performance even more by
the use of a technique called I<pipelining>.  This means that the
client sends multiple requests down the connections without waiting
for the response of the first request before sending the second and so
on.  This can have a dramatic effect on the throughput for high latency
links [6].

Some of the HTTP/1.1 features are available in deployed
HTTP/1.0 clients and servers.  Persistent connections can sometimes be
used with HTTP/1.0 if the clients send a "Connection: Keep-Alive"
header.  Most of today's HTTP/1.0 clients send the Host header.

Beyond HTTP/1.1 we have HTTP/NG, which is a project still in the
research phase [7]. HTTP/NG is an attempt to take a more radical
approach.  The main "features" are making the protocol binary in order
not to waste bytes on long human readable headers and direct support
for multiplexing over a single network connection.  It is not clear
that this will be a big enough win to make the world move away from
the HTTP/1.X protocols.


=head1 History of libwww-perl

The libwww-perl project started at the first WWW conference in 1994
(Geneva) where Martijn Koster discussed MOMspider with Roy Fielding.
Martijn suggested that it would be a good thing if the reusable
components of this program were broken out into a library.  The result
was the libwww-perl library for perl4 that Roy maintained [8,9].

At one point, both Martijn and Gisle Aas (this article's author) had
made their own separate modulifications of Roy's library to better
suit the possibilities that perl5 provided.  We joined forces and made
several alpha releases together.  Unfortunately, Martijn had a little
disagreement with his employer about the intellectual property rights
of work done outside hours.  To safeguard LWP's continued availability
to the Perl community, he asked me to take over maintenance of the
package.

The C<LWP::> module name was introduced by Martijn in one of the alpha
releases.  It was early on pointed out that this name could be confused
with what some implementations of threads called themselves, but no
better name alternatives emerged.  The last mailing list messages on
this matter was <"6362 Tue Jul 18 09:59:46 1995"@mhs-relay.ac.uk>
where Martijn concluded that "OK, so we all agree LWP stinks :-)".
The name stuck.

On 1996-05-26 we made the first non-beta release of libwww-perl.  It
was called release 5.00 because it was for perl5 and to make some room
for Roy to maintain libwww-perl for perl4 which at that time was (and
still is) called libwww-perl-0.40.

In the two years that have passed since, lots of bugs have been fixed
and some features added, but nothing radical has happened.  We have
not been eager to try to adopt HTTP/1.1 features, because it seemed
clear that decent support could not be achieved without a larger
restructuring of how the basic protocol services were implemented.

One important work that inspired the rewrite described here was Marc
Langheinrich's ParallelUserAgent implementation.  It extended
libwww-perl with the possibility to access multiple servers (or have
multiple connections to the same server) at the same time [10].

In November 1997 I started on a rewrite of the basic services provided
by libwww-perl.  The goal was to provide full HTTP/1.1 client support
and at the same time make the library both more flexible and
(optionally) more lightweight.  Little happened until March 1998, but
then I finally got the opportunity and tuits enough to start working
on this project almost full time.  The software is, at the time of
writing, quite usable.  It is distributed under the name I<LWPng> and
is available on CPAN [11]. It is expected to be renamed as
libwww-perl-6.00 when its beta phase is over.


=head1 A short introduction to libwww-perl-5

The libwww-perl library is based on HTTP-style communication.  The
main model is that all requests through any protocol module are forced
into an HTTP straight-jacket. This makes things very easy, consistent,
and nice.  This model is also what libwww-perl has inherited from, and has
in common with, w3c-libwww [12].

LWP provides an object oriented model of HTTP-style messages that are
passed between servers and clients.  The I<HTTP::Request> class models
the message sent from a client to a server.  The I<HTTP::Response>
class models the message sent back from a server to a client.  On
their way between the client and the corresponding server, these
messages are converted to the actual protocol on the wire which in turn
will depend on what kind of server we are accessing (i.e. does not
have to be HTTP).

Instances of the I<LWP::UserAgent> class are created by client
applications and serve as the interface between the application and a
network of accessible servers (see figure below).  The
I<LWP::UserAgent> provides the request() method that accepts an
I<HTTP::Request> object as an argument and will (eventually) return an
I<HTTP::Response> object when the corresponding server returns an
answer.

[[fig1.ps]]

The canonical example of LWP client usage looks like this:

  use LWP::UserAgent;
  my $ua = LWP::UserAgent->new;

  my $req = HTTP::Request->new(GET => 'http://www.linpro.no/lwp/');
  $req->header(Accept => 'text/html');

  # send request to server and get response back
  my $res = $ua->request($req);

  # check the outcome
  if ($res->is_success) {
     print $res->content;  # for instance
  } else {
     print "Error: " . $res->status_line . "\n";
  }

The I<HTTP::Daemon> class provides the corresponding interface for
LWP-based server applications.  Through instances of this class a server
application will get hold of a connection initiated by a client and
will be able receive I<HTTP::Request> objects from this connection and
send back I<HTTP::Response> objects.  Since the client and server
interface use the same message objects, it is trivial to write a simple
proxy server [13].

Features of libwww-perl include:

=over 3

=item *

Support for accessing resources identified by http, https, gopher,
ftp, file, data, mailto and news URLs within the HTTP framework.

=item *

Basic and Digest authorization

=item *

Automatic redirect handling

=item *

Communication through HTTP proxies

=item *

Handling of URLs (both absolute and relative)

=item *

Cookie handling

=item *

RobotRules (/robots.txt)

=item *

A few command line clients

=item *

Coexistence with the Tk modules

=back


=head1 LWPng design

It became evident that a redesign of the underlying protocol modules
and the main interfaces was needed in order to support HTTP/1.1
clients properly. The major shift was that we now wanted to be able to
transparently support multiple persistent connections to the servers,
and that we wanted these connections to be used efficiently (i.e. we
should be able to support pipelining too).

As for LWP5, the programming interface still ought to hide the details
of connection set up and tear down, but in order to allow the library
to utilize its connections efficiently it would need to have more than
a single request to work with at a time.  This meant that the
application would have to feed the library with all requests to be
carried out as early as possible and then it would be the library's
task to try to use its connections as optimally as possible.  The
optimization would be guided by various parameters that usually can be
set by the application (throughput, latency, limit number of
connections, limit on number of outstanding requests per connection,
etc.).

Some other design goals and guidelines included:

=over 2

=item *

The abstractions provided should be fairly high level.  The
HTTP::Request and HTTP::Response object interfaces of LWP5 have shown
themselves to work well and be valuable.  We still wanted a design
based on passing these objects around.

=item *

The redesigned library should be no more difficult than the old LWP5
to use.  The application programmer should not have to work harder.

=item *

The redesigned library should be backwards compatible with LWP5.  Old
applications should continue to run. It would, in general, be acceptable
if they do not run as efficiently as applications that have been
rewritten to the new interface.

=item *

The library implementation should be efficient.  The main issues are
startup time for applications (i.e. not too much unused source code
for perl to compile), and efficient use of network connections and
operating system (i.e. not many small read/write requests and no
polling.)

=item *

We wanted to use this opportunity to generalize some parts of the
interface.  For instance, the old $ua->from and $ua->agent methods
could be generalized to something that is able to set up any default
headers to be added to requests before they are sent out.  Having
this would also solve much of the problem of setting up authorization
headers in requests.

=item *

Optional features of the library should add minimal penalty to
applications that don't use them.

=item *

Most features of the library should be made optional.

This hopefully interacts well with the preceding point and should
allow a wider range of HTTP client applications to be built.  The
library can be comprehensive and feature-rich and still usable by
small/simple applications that mainly care about speed.  They should
not have to shy away from LWP because it is too big and too slow to
start.

=item *

"Easy things should be easy, hard things possible." This Perl
slogan hopefully applies to this design too.

=item *

There should be minimal binding between the modules and classes
within the library.  One should be able to use only selected parts of
the library and individual modules should be usable in other contexts
than LWP.

=item *

There should be no need for signal handling and no use of the alarm()
to implement timeouts.

One of the things that created many problems for LWP5 was that it
initially used alarms to implement timeouts.  This was problematic both
because alarms are not available everywhere and because the perl signal
handling is not as reliable as it ought to be.

=item *

Happy coexistence with the Tk module.  One should be able to write
client applications that have graphical user interfaces.

=back

The last item in the list above was one of the reasons why we
concluded early on that the redesign should be based on an event-driven
framework.


=head1 Event-driven programming

A prerequisite for supporting the persistent connections that
HTTP/1.1 requires, is to be able to handle both reading and writing
from multiple network connections at the same time.  One would also
like to manage idle connections with some timeout and to notice
if the server decides to close the connections before we do.  These
requirements basically mean the adoption of an event-driven model or
a model based on separate threads of control.  We have chosen to go
for the event-driven model.  Thread support is still new to Perl
and will not work everywhere when available.  An event-driven
framework will continue to work with threaded Perls.  A threaded
framework would require a thread enabled Perl to run.  Ousterhout
mentions several other reasons why an event-oriented solution is to be
preferred over a thread based one [14].

Event-oriented programming is not always easy.  One of the main
difficulties is that the event handlers must be written to return
quickly and one must explicitly store away the state between
invocations of the handlers instead of letting the state be implicit
by the natural flow of the program.  At times it might be useful to
allow the event loop to be nested (for instance to allow prompting) and
this imposes the burden of creating event handler routines that are
reentrant.

Let us start by investigating the impact of the event-driven framework
on the overall LWPng programming model.  The basic model for sending
requests and receiving responses in LWP5 used to be:

  $res = $ua->request($req);   # return when response is available
  if ($res->is_success) {
      #...
  }

With the new event-driven framework it becomes:

  $ua->spool($req1);   # returns immediately
  $ua->spool($req2);   # can send multiple request in parallel
  #...

  mainloop->run;       # return when all connections are gone

Request objects are created and then handed off to the $ua, which will
queue them up for processing.  As you can see, there is no longer any
natural place to test the outcome of the requests, since the spool()
method returns before the response is available.  What happens is that
the requests in a way live their own lives.  The request objects will
be notified (though a callback method) when the corresponding
responses or response data become available.  The application
programmer will have to set up handlers (in the requests) that react
to these events.

This does not mean that all old programs must be rewritten.  The
following sample code shows one way to emulate something very similar
to the old behaviour:

  my $req = LWP::Request->new(GET => $url);

  my $res;
  # set up a handler to be invoked when the response is available
  $req->{done_cb} = sub { $res = shift; };

  $ua->spool($req);
  mainloop->one_event until $res;  # runs until response is available

  if ($res->is_success) {
      #...
  }

The main clue here is that we run a nested event loop that emulates
the blocking that $ua->request would otherwise do.  This technique
will be used to emulate the old $ua->request() and
$ua->simple_request() interfaces for compatibility purposes.

The same technique with nested event loops can be used to implement an
interface that basically gives us:

   open(FH, "http://www.perl.com") or die;
   while (<FH>) {
       print;
   }

The current LWPng implementation and the examples above are based on
the event loop implementation provided by the LWP::EventLoop class.
This class is fairly small and quite simple.  It supports exactly what LWPng
needs and not much more.  The main problem is the introduction of yet
another event loop and that it will create problems if the application
wants to use LWPng together with modules based on some other event
loop implementation.

The reason LWP::EventLoop was made in the first place was that none of
the other event loops that existed on CPAN satisfied the needs of LWPng.
The Tk event loop would not allow a socket to be both readable and
writable at the same time, and requiring Tk for every LWP application
did not seem very attractive.  Graham Barr's I<Event> looked promising,
but was still too alpha and required upgrading the IO modules.
The EventServer module was too big and relied too much on alarm() to be
something I would trust.

Since the happy coexistence with Tk was one of the requirements for the
new library, we will have to move away from LWP::EventLoop in the
future.  The hope is that Perl itself will adopt some event loop
mechanism (possibly based on Graham's Event) and that both Tk and LWP
will be based on it instead of each providing their own.


=head1 Major classes

LWPng continues in the object-oriented tradition of LWP5 and it
introduce some new classes.  Some of these replace the corresponding
classes in LWP5.  Some add features not present before.

One important design criteria was backwards compatibility.  It means
that the old interfaces must be kept, and if we want to clean up an
interface we basically have to start afresh with a new class
name. This allows old code to continue to work because it still uses
the old names.  Often it is a good idea to re-implement the old
interfaces on top of the new interface. This allows us to keep
backwards compatibility and at the same time get one place to fix bugs
and add enhancements.  It also allows the new library to remain lean
and not suffer from too much compatibility bloat, and it might even be
used as a validation test of the generality of the new interfaces.

The classes that have changed name and interfaces are:

=over 2

=item *

The old LWP::UserAgent has become LWP::UA.  The name was changed
because we wanted to make a general cleanup of the interface.  The
name change also makes the transition period easier as the old LWP5
library can be installed together with the new library without
conflict.

=item *

The old LWP::Protocol::* modules have been replaced with LWP::Conn::*
modules.  The event-oriented framework requires a completely different
interface towards and from the low-level protocol modules.  Both
versions must be able to work side by side for some time.

=item *

The LWP::Authen modules have changed interface and therefore name.
We have kept the prefix, but will now use all lower case for the
scheme name part, e.g. LWP::Authen::digest

=back

Completely new classes include:

=over 4

=item LWP::Request

This is a subclass of HTTP::Request that allows us to attach response
handlers and callbacks to these objects.  Basically all the parameters
given (and returned) by the old $ua->request method must now be
represented as attributes of the request object.

=item URI::Attr

This class makes it possible to attach attributes based on
hierarchical levels of the URI name space.  It is used for various
configurations and for remembering facts about places in this space.
The main benefit is that it allows more generalizations of the
interface and the configuration of the library.

=item LWP::Hooks

LWP::Hooks is a mix-in class that allows handlers to be dynamically
registered on the object and executed.  LWP::UA and LWP::Request
inherit its methods.

=item LWP::StdSched

Policy decisions about how many and which connections to set up or
tear down at given points are delegated to a special scheduler object
by the LWP::UA.  This arrangement allow this behaviour to be easily
replaced or updated at any time.  The LWP::StdSched is the default
scheduler that the library will instantiate if the application does
not set up some other scheduler before requests are spooled.  The
LWP::StdSched is a very simple-minded scheduler that tries to adhere
to various limits on the number of connections to create.

=item LWP::Sink

HTTP concepts like chained Transfer-Encoding or Content-Encoding
suggest that we need a way to transform the message content back to
its original form.  Since we want to be able to handle arbitrary
sized content and we want to be able to make the content available to the
application as early as possible, a stream-based organization of
transformation modules is useful.  LWP::Sinks that can accept data,
do something with it, and then send it off to some other sink can be
used as transformers.  The library contains prebuilt transformer sinks
that, for instance, deal with C<deflate> or C<base64> encoded data.
Transformers can be linked together to form stream pipelines.


=item LWP::EventLoop

The event loop class has been mentioned before.  It is basically just
a wrapper around the C<select()> system call.  File handlers can be
registered and the event loop will make appropriate callbacks when a
handle becomes readable or writable.  Timer events can also be
registered.  One handy feature for LWPng is that you can set timeouts
on the individual file handlers to get an C<inactive> callback if no
other data transfer callbacks have been invoked for some specified
time.

=back

We will now investigate the major interfaces of some of these classes
in some more detail.

=head2 LWP::UA

The LWP::UA represents the main interface of the client library.  The
main entry point is the spool() method.  All requests to be processed
by the library enter through this "gate."  Before a request is handed
over to some protocol module, the LWP::UA will invoke any
I<spool_handlers> registered.  The handlers are simply a list of
subroutines and can be registered dynamically by the application.

These handlers provide the main strategy of implementing optional
features and achieving zero overhead for applications that don't use
the features.  The bare LWP::UA is only capable of doing the following
basic things:

=over 3

=item 1.

It provides the spool() method, and when it is invoked...

=item 2.

it knows how to run any handlers registered.

=item 3.

If no handler signaled that the request has been handled, then it
knows how to dynamically load a protocol module by looking at the
scheme part of the URL and to pass the requests to the module.

=item 4.

It tells the scheduler object to take a look at the situation in order
to figure out if any new connections ought to be set up
($sched->reschedule).

=back

The handlers are invoked with a reference to the UA and a reference to
the request as arguments.  If a handler returns a TRUE value, then it
signals that the request has been handled and that no further handlers
are to be invoked for it.  Handlers are also used to modify the
request on its way, for instance to add various headers.  They can
register response callbacks or response handlers to be triggered when
the response is available.  In the last two cases the handler must
return a FALSE value so that the request is processed further.

One problem with the current handler interface is that there is really
no way to control the order that handlers are applied to the requests.
This probably ought to be fixed.  Another idea would be to attach the
handlers to the URI::Attr tree.  That would allow the set of handlers
to be applied to depend on the request URL.

The following handlers are currently provided by the library.
Handlers which are not used do not have to be loaded either, which
means that perl does not waste time compiling their source.

=over 4

=item default_headers

This handler adds static headers to a request where these headers are
not already present.  It is, for instance, used to add headers like
C<User-Agent> and C<From>.  The headers to be merged with the request
are looked up in the URI::Attr tree.

=item date

This handler adds a C<Date> header to the request if applicable.  Not
really very useful, but it shows how to write trivial handlers to cope
with dynamic headers that the I<default_headers> handler can't do.

=item authentication

This handler tries to add an C<Authorization> header to the request
that we somehow know might need it.  It looks up the realm for the URL
and maps this to some Authen object that can add the corresponding
header.  This works together with the Authenticate response handler
(described below).

=item proxy

This handler tries to set the proxy attribute of a request.  The proxy
configuration is looked up in the URI::Attr and might indicate that
some URLs are to be passed through a proxy.  It can also add a
C<Proxy-Authorization> header to the request, for proxies that insist
on that.

=item head_parser

This handler registers a response data handler with the request.  The
registered handler will create an HTML::Parser object, if the response
contains an HTML document and pass the first few chunks of document
data through it.  The main reason to do that is to extract any <BASE>
element that will influence how relative URLs are to be interpreted.

=item cookies

This handler will let an HTTP::Cookies object add one or more
C<Cookie> headers to the request, and will also register a response
callback that will let the HTTP::Cookies object extract any
C<Set-Cookie> headers.

=back

The handlers currently implemented only modify the request on its way
to the server.  Some other uses of spool handlers might include:

=over 4

=item Local cache

Check if we have a local copy of the response, and return it instead.
If no valid local copy exists, register a response handler to update or
validate the local cache.  Might also add C<If-None-Match> or
C<If-Modified-Since> headers to the request when we have a stale local
copy.

=item Specific scheme handling

An application might, for instance, want to handle <about:> URLs similar to
what Netscape does by registering a handler.

=item URL rewriting

Implement automatic fast redirection inside the client

=item Netnanny

Block indecent parts of the URI space

=back

As we have seen, many of the handlers use the common URI::Attr object
member of the UA to obtain their configuration information.

=head2 URI::Attr

For many situations, we have found a need to set up configuration
parameters and other attributes related to the hierarchical URI name
space.  Many of the handlers should work differently depending on
scheme, domain, server, or path.  For example, the authentication
handler might want to remember "realms" per server and remember which
path prefixes are protected within the different realms.

The URI::Attr class instances are trees of hashes.  A specific
absolute URI defines a path in the URI::Attr tree, and the main
operation of URI::Attr is to return all hashes found on this path.
This allow us to efficiently look up all attributes that are relevant
to a specific URI.  Since order along the path is preserved, we are
able to override specific attributes at lower hierarchical levels of the
URI name space.

The LWP::UA object has a URI::Attr instance as a member.  It
provides direct access to this member through the methods
$ua->uri_attr_plain, $ua->uri_attr_update.  Configuration for all the
handlers and the protocol machinery are placed within this tree.

Let's show a simple proxy configuration as an example.  We might want
all HTTP requests to go through our caching proxy, but not for request
to servers within our local domain.  This can be expressed like this
(assuming our local domain is I<.perl.com>):

  $ua->uri_attr_update(SCHEME=>"http:")->{proxy} = "http://proxy.perl.com";
  $ua->uri_attr_update(DOMAIN=>"http://dummy.perl.com/")->{proxy} = undef;

The proxy handler can then simply find out if a request needs to go
through a proxy, with a call like this:

  $proxy = $ua->uri_attr_plain($url, "proxy");

This will return the name of the proxy server "http://proxy.perl.com"
if applied to an URL like "http://www.yahoo.com", and will return
C<undef> if the URL is "http://mox.perl.com".


=head2 LWP::Request

The spool() method of LWP::UA accepts one or more LWP::Request object
references as arguments.  The LWP::Request class is derived from the
HTTP::Request class and inherits all its attributes.  We use
a subclass because it needs to support some callback methods that are
invoked during reception of the response from the server.  There are
two such methods:

   $req->response_data($data, $res);
   $req->response_done($res);

The response_data() callback method is invoked repeatedly as parts of
the content of the response becomes available.  The first time it is
invoked is right after the headers in the response message have been
parsed.  At this point, $res will be a reference to an HTTP::Response
object with response code and headers initialized, but the message
content will be empty.  There is no guarantee that this method will be
called at all for a given request.

The default implementation of response_data() will run any
I<response_data> hooks and will call the registered data callback
function if it exists.  If no data callback function is defined, then
data is simply appended to the content of the response message.

The response_done() callback method is invoked when the whole response
has been received.  It is guaranteed that it will be invoked exactly
once for each request spooled (even for requests that fail.)

The default implementation of response_done() will run any
I<response_done> hooks.  Then it will try to run any
I<response_handlers>.  If none of the handlers signaled that the
response has been handled (for instance by sending a followup
request), then we either call the done callback function or we
"deliver" the response by calling the $ua->response_received($res)
method.

Applications can either subclass LWP::Request, to provide their own
versions of response_data() and response_done(), or they can just
register handlers and callback functions.  The last option is probably
to be preferred.

There are two other attributes in LWP::Request worth mentioning here;
the $req->proxy field is simply the name of the proxy to send
the request to, and the $req->priority field can be used to make some
requests more important than others.

Again, the handlers allow more features to be optional and ensure
minimal overhead for applications that don't use them.  Currently, the
following handlers are provided:

=over 4

=item redirect handler (response_handler)

This is a handler that makes sure that the library automatically and
transparently follows any redirect responses.  If it kicks in, it will
create a follow-up request as a copy of the current request, modify
the URL or proxy setting and then respool it with the UA.

=item authentication handler (response_handler)

This is a handler that deals with "401 Unauthorized" or "407 Proxy
authentication required" responses.  It tries to dynamically load the
LWP::Authen module that corresponds to the authentication scheme (only
I<Basic> and I<Digest> are currently provided), and then lets the loaded
module deal with asking the user for a user name and a password and with
setting up the C<Authorization> or C<Proxy-Authorization> header in a
copy of the request.  If all works well the new request is respooled with
the UA.

=item head parser (data hook)

The head parser looks at the <HEAD> section of HTML documents to
extract header fields like C<Content-Base> and C<Title>.

=item extract_cookies (done hook)

If the I<cookies> spool handler is enabled, then it will register a
response_done hook in order to look at the C<Set-Cookie> headers of
all responses.

=back

=head2 LWP::Conn::*

The guts of the library are in the LWP::Conn classes.  This is where
all the low level protocol handling takes place.  Each protocol is
implemented by its own LWP::Conn class.  For instance, the HTTP
protocol is implemented by the LWP::Conn::HTTP class.  Instances of
these classes represent a single (logical) network connection to a
corresponding kind of server.  The scheduler within the UA is
responsible for deciding how many connections to set up for each of
the servers with which we are going to communicate.

It is really these connection objects that drive the activity within
the library.  As network and timer events happen, we get callbacks into
the connection objects, and these will make further (higher level and
fewer) callbacks to the rest of the library.

The other source of activity within the library is the application
itself.  It can either spool further requests, or it can kill running
requests (and connections).  The application must also have an
interface to the the event loop.  In simplest case, it only passes
control to the event loop after starting things off (using
C<mainloop-E<gt>run> as shown in examples above).

The following figure shows how the application relates to the library
and the major call paths involved.

[[fig2.ps]]

An LWP::Conn object looks after itself based on the socket and timer
callbacks that it registers with the event loop.  It obtain its
workload and reports progress to some object that it denotes as its
manager.  A single manager can be shared between multiple connection
objects.  A reference to the manager is passed to the LWP::Conn object
constructor, together with a specification of where to connect:

  $conn = LWP::Conn::HTTP->new(MangagedBy => $mgr,
                               Host => $host,
                               Port => $port,
                               ...);

The following are the methods that a connection will invoke on a
manager during its life:

  $mgr->get_request($conn);
  $mgr->pushback_request($conn, @requests);

  $mgr->connection_active($conn);
  $mgr->connection_idle($conn);
  $mgr->connection_closed($conn);

During processing of requests obtained with get_request() the
connection object will create LWP::Response objects and will invoke
the response_data() and response_done() callback methods described
above.

The following are the two methods which can be invoked on a live
connection by the manager.

  $conn->activate;  # reactivate an idle connection
  $conn->stop;      # kill it early

As you can see, the interface between a connection object and its
manager is really quite simple.  This makes it easy for applications
with special needs to use any of the LWP::Conn implementations in
isolation without the rest of the library.  All the application has
to do is to provide an object that implements the 5 methods that make
up the manager interface.  For normal use we send requests through
the LWP::UA, and the library will internally use LWP::Server objects
as connection managers.


=head2 LWP::Conn::HTTP

The LWP::Conn::HTTP module implements the HTTP protocol for LWPng.  A
single LWP::Conn::HTTP instance represents a single network connection
to an HTTP server.  Several request/response exchanges can take place
over this single connection. Pipelining of requests is supported too.

The design of this module was much inspired by the "State" pattern
described in Design Patterns [15].  The main intent of this pattern is
described like this:

  Allow an object to alter its behaviour when
  its internal state changes.  The object will
  appear to change its class.

This is usually achieved by having the main object (the connection)
maintain a reference to an object that represents the current state.
All state-specific methods are then delegated to this state object,
and state changes involve updating this reference to point to some
other state object.

For libwww-perl, Perl's dynamic approach to object orientation came
handy.  With Perl we can actually (and efficiently) change the class
of an existing object at run-time.  This means that a Perl
implementation can simplify the "State" pattern a lot.

Each state, that the HTTP connection object can be in, is represented by
its own LWP::Conn::HTTP subclass, and state transitions are simply a
calls to the C<bless> builtin.  The use of classes makes it easy
to express sub-states (as subclasses) that behaves mostly like its
base state, but modify some of its behaviour.

The states used by LWP::Conn::HTTP are:

=over 4

=item Connecting

In this state, we have called the non-blocking connect(2) and got
C<EINPROGRESS> back.  We wait until the socket becomes writable, which
usually means that the connection attempt was successful.  On success,
we switch to the Idle state and call $self->activate().

=item Idle

In this state, we have nothing to do.  We wait until timeout() or
somebody calls the activate() method.  We must also monitor the
network connection so that we notice if the server decides to close it
before we do.

If the activate() method is invoked, then we try to obtain a new request to
send ($mgr->get_request).  If this succeeds, then we switch to the Active
state.

=item Active

In this state, we are sending one or more requests, and are prepared to
read any response that comes back.  When the headers of a response have
been received, they are parsed, and we switch to one of the following
sub-states, depending on the how the message content are to be
delimited.  When the whole message content has been received, we try to
obtain another request to send; and, depending on the outcome of this we
switch back to either the Active or the Idle state.

=item ContLen

This is an Active subclass.  We maintain a counter of the number of
bytes to still expect for the message content, and we read data until
this counter reach zero.

=item Chunked

This is an Active subclass.  We must read and parse chunk headers,
then read the corresponding number of chunk bytes.  This repeats until
a 0-chunk is received.  Finally, we must be prepared to parse trailer
headers for the response.

=item Multipart

This is an Active subclass.  We read content data until the specified
boundary byte pattern is found.

=item UntilEOF

This is an Active subclass. We read content data until the server
closes the connection.  This is also the HTTP/1.0 behaviour.

=item Closed

This is the state that the connection enters when it dies and the
socket is closed.  No method calls are allowed any more.

=back

The following picture illustrates the state transitions that take
place:

[[fig3.ps]]

The LWP::Conn::HTTP constructor takes the name of the server host and
the port to connect to as arguments.  It creates a non-blocking socket
and tries to connect to the specified server, and will then either
enter the Connecting or Idle state, depending on what connect(2)
returns.  We also register timeout callbacks, which makes sure
that this connection instance looks after itself.

=head2 LWP::Conn::FTP

The LWP::Conn::FTP module implements the FTP protocol for LWPng.  A
single LWP::Conn::FTP instance represents a single command connection
to an FTP server.  The creation of the data connections used to
transfer the content of the files is not visible outside a
LWP::Conn::FTP object.

The LWP::Conn::FTP module uses a similar approach to LWP::Conn::HTTP,
but it has many more states to represent the conversation that has to
take place on the command connection.  The concept of representing
persistent connections within the library has turned out to be a big
win for the FTP support.  It is now straightforward to provide
persistent FTP connections that do not tear down the command socket
after each request.

=head1 Some benchmarks

LWPng is still alpha software, so it might be a bit premature to do
serious benchmarking of it.  No work on trying to optimize the library
for speed has yet been done, as we are still focusing on getting the
programming interface defined.

The test below is based on simple scripts that fetch a single HTML
page, parse it and then fetch all images referenced.  This is similar
to what a graphical browser would have to do to load a page.  We
measure the complete downloading time using the Unix 'time' command
which reports elapsed real time, as well as how much CPU time is used.
We don't go into deeper detail such as looking at the number of TCP
packets generated or the number of system calls invoked.

These tests results have been made on a 90Mhz i586 PC running RedHat
Linux 4.0.  We have used perl5.004_04, libwww-perl-5.32 and
lwpng-alpha-0.20 during the test.  The tests performed were:

=over 3

=item LWP5

The page-fetcher script using the old libwww-perl-5 library.  The
script will fetch the HTML page and the images in sequence and create
a new connection for each resource fetched.

=item LWPng

The page-fetcher script using the new LWPng interface.  The script
will start fetching the images as soon as the corresponding part of
the HTML document has been received.

The LWPng library behaviour depend on various parameters.  C<MaxConn>
is the number of parallel connections we allow it to have to a single
server.  C<ReqLimit> sets a limit on the number of requests it will
send over a single connection.  Setting this value to 1 effectively
disables persistent connections.  C<ReqPend> sets a limit on the
number of requests we can have outstanding on a connection before we
must wait for a response.  Setting this value to 1 effectively
disables pipelining.

The LWPng script has been tested with the following combinations of
the parameters:

           MaxConn   ReqLimit   ReqPend
         +---------+----------+----------
 LWPng-A |    1          1         1
 LWPng-B |    2          1         1
 LWPng-C |    1        100         1
 LWPng-D |    1        100         3
 LWPng-E |    2        100         3

The LWP5 and LWPng-A tests should be comparable as the libraries would
have to set up the same number of network connections.

=item SOCK

A simplified version of the page-fetcher script that just hard-codes
downloading of the URLs over a single persistent IO::Socket::INET
connection (bypassing any LWP code).  All requests are sent to the
server using a single print, and then we read the responses until the
server close the connection.  The numbers reported for this test
should indicate an upper limit on the downloading speed we can hope to
achieve with Perl.

The LWPng-D and SOCK tests should be comparable.  Both download all
documents over a single connection with pipelining.

=back

I used I<www.microsoft.com> as the server to run this test
against.  The reason was simply that this was the first faraway site
I found that implemented HTTP/1.1 persistent connections and at the
same time used a lot of image icons.  At the time of the test run,
there were 17 referenced images to fetch.  The average image size was
1761 bytes.  Of the images 8 had a size less than 256 bytes.  I
believe that the bottleneck on the connection was the 64 kbit ISDN
line to my ISP.

The results were:

 LWP5)    3.69user 0.31system 0:20.29elapsed 19%CPU
 LWPng-A) 5.40user 0.34system 0:20.97elapsed 27%CPU
 LWPng-B) 5.46user 0.33system 0:21.61elapsed 26%CPU
 LWPng-C) 4.79user 0.26system 0:14.86elapsed 33%CPU
 LWPng-D) 5.12user 0.25system 0:12.40elapsed 43%CPU
 LWPng-E) 4.99user 0.31system 0:10.76elapsed 49%CPU
 SOCK)    0.78user 0.08system 0:11.28elapsed 7%CPU

The first observation to make is that currently LWPng is not more
lightweight than LWP5.  It uses about 50% more CPU to process the
requests.  We observe that we save a lot of CPU time by not using
LWP at all.

We see that the use of persistent connections really did help.  The
time used to download the page decreased from 21s to 15s (30%); and
after adding pipelining, it went down to 12.5s (additional 12%).  Using
multiple connections to the server (B,E) did not do much to decrease
download time.  We also observe that LWPng-D download time is fairly
close to the SOCK time.

For the next test, we downloaded the I<www.microsoft.com> front page
locally and then accessed it from a Apache server over the local
Ethernet.  The results were:

 LWP5)    4.01user 0.25system 0:04.32elapsed 98%CPU
 LWPng-A) 5.20user 0.34system 0:05.61elapsed 98%CPU
 LWPng-B) 5.20user 0.31system 0:05.63elapsed 97%CPU
 LWPng-C) 4.75user 0.30system 0:05.12elapsed 98%CPU
 LWPng-D) 4.74user 0.31system 0:05.09elapsed 99%CPU
 LWPng-E) 4.93user 0.17system 0:05.11elapsed 99%CPU
 SOCK)    0.78user 0.24system 0:01.15elapsed 88%CPU

What happened here was that CPU became the bottleneck.  Again we see
that LWPng uses more CPU than LWP5 to achieve the same thing.
Persistent or parallel connections did nothing to help.  It would be
interesting to redo this test after LWPng has been through a round of
profiling and optimizations.

A faster perl (or faster hardware) would help LWP too.

=head1 Conclusions

This article discussed the design of HTTP/1.1 support for the next
generation of the LWP modules.  The new modules allow you to write
client applications that manage multiple persistent connections to its
peer servers.

The new design looks promising but the performance must improve in
order to fulfill the design goals.  Still there are spots in the
programming interface that need more thought.  We also need more
testing and feedback from application writers before we can say that
the interface has stabilized and we go to the beta phase of bug-fixing
and further optimizations.

=head1 References

=over 4

=item [1]

The LWP home page - <URL:http://www.linpro.no/lwp/>

=item [2]

RFC 1945 - "Hypertext Transfer Protocol -- HTTP/1.0.", Berners-Lee,
T., Fielding, R. and H. Frystyk., MIT/LCS, UC Irvine, May 1996.

=item [3]

RFC2047 - "MIME (Multipurpose Internet Mail Extensions) Part
Three: Message Header Extensions for Non-ASCII Text", Moore, K.,
University of Tennessee, November 1996.

=item [4]

RFC 2068 - "Hypertext Transfer Protocol -- HTTP/1.1", Fielding, R.,
Gettys, J., Mogul, J., Frystyk, H., Berners-Lee, T., UC Irvine,
Digital Equipment Corporation, M.I.T., January, 1997.

=item [5]

draft-ietf-http-v11-spec-rev-03.txt - "Hypertext Transfer Protocol --
HTTP/1.1", Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter
L., Leach P., Berners-Lee, T., HTTP Working Group, March, 1998.

=item [6]

"Network Performance Effects of HTTP/1.1, CSS1, and PNG", Frystyk
Nielsen, Gettys, Baird-Smith, Prud'hommeaux, Lie, Lilley. W3C, 1997.
<URL:http://www.w3c.org/Protocols/HTTP/Performance/Pipeline.html>

=item [7]

<URL:http://www.w3c.org/Protocols/HTTP-NG/>

=item [8]

MOMspider - Roy Fielding <URL:http://www.ics.uci.edu/pub/websoft/MOMspider/>

=item [9]

libwww-perl-0.40 - Roy Fielding <URL:http://www.ics.uci.edu/pub/websoft/libwww-perl/>

=item [10]

Parallel LWP User Agent - Marc Langheinrich <URL:http://www.cs.washington.edu/homes/marclang/ParallelUA/>

=item [11]

CPAN - Comprehensive Perl Archive Network - <URL:http://www.perl.com/CPAN/>

=item [12]

w3c-libwww - H. Frystyk <URL:http://www.w3.org/Library/>

=item [13]

"Anynoumus Proxy Server", Randal L. Schwartz, Web Techniques, February 1997
<URL:http://www.stonehenge.com/merlyn/WebTechniques/col11.html>


=item [14]

"Why Threads Are A Bad Idea (for most purposes)", John K. Ousterhout,
1996 USENIX Technical Conference
<URL:http://www.scriptics.com/people/john.ousterhout/>

=item [15]

"Design Patterns - Elements of Reusable Object-Oriented Software",
E. Gamma, R. Helm, R. Johnson, J. Vlissides.  1995 Addison Wesley.

=back


=cut
